<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Projectile Motion</title>
    <style>
      body {
        background: #f5f5f5;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        font-family: sans-serif;
      }
      canvas {
        background: white;
        border: 1px solid #ccc;
      }
      .controls {
        margin-bottom: 10px;
      }
      label {
        font-size: 14px;
        margin-right: 8px;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <label for="angle">Launch Angle (degrees):</label>
      <input type="number" id="angle" value="45" min="1" max="89" />
      <button onclick="startAnimation()">Launch</button>
    </div>
    <canvas id="canvas" width="900" height="550"></canvas>

    <script>
      const g = 9.81; // gravity (m/sÂ²)
      const flightTime = 9; // total time in seconds
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const margin = 50; // padding around plot area
      let scale = 10; // pixels per meter (calculated dynamically)

      function startAnimation() {
        const angleDeg = parseFloat(document.getElementById("angle").value);
        const angleRad = (angleDeg * Math.PI) / 180;

        // Vertical velocity required for 9s flight:
        const Vy = (g * flightTime) / 2;
        const Vx = Vy / Math.tan(angleRad);
        const speed = Math.sqrt(Vx * Vx + Vy * Vy);

        console.log(`Initial speed = ${speed.toFixed(2)} m/s`);

        // Calculate ranges
        const maxX = Vx * flightTime;
        const maxY = (Vy * Vy) / (2 * g);

        // Fit to canvas
        const usableWidth = canvas.width - 2 * margin;
        const usableHeight = canvas.height - 2 * margin;
        const scaleX = usableWidth / maxX;
        const scaleY = usableHeight / maxY;
        scale = Math.min(scaleX, scaleY); // keep aspect ratio

        animate(Vx, Vy, maxX, maxY);
      }

      function drawAxes(maxX, maxY) {
        ctx.strokeStyle = "#ddd";
        ctx.fillStyle = "black";
        ctx.font = "12px sans-serif";

        const stepX = Math.max(10, Math.ceil(maxX / 10));
        const stepY = Math.max(10, Math.ceil(maxY / 10));

        // vertical grid lines
        for (let x = 0; x <= maxX; x += stepX) {
          const cx = margin + x * scale;
          ctx.beginPath();
          ctx.moveTo(cx, canvas.height - margin);
          ctx.lineTo(cx, margin);
          ctx.stroke();
          ctx.fillText(x, cx - 10, canvas.height - margin + 15);
        }

        // horizontal grid lines
        for (let y = 0; y <= maxY; y += stepY) {
          const cy = canvas.height - margin - y * scale;
          ctx.beginPath();
          ctx.moveTo(margin, cy);
          ctx.lineTo(canvas.width - margin, cy);
          ctx.stroke();
          ctx.fillText(y, margin - 30, cy + 3);
        }

        // axes
        ctx.strokeStyle = "black";
        ctx.beginPath();
        ctx.moveTo(margin, canvas.height - margin);
        ctx.lineTo(canvas.width - margin, canvas.height - margin); // x-axis
        ctx.moveTo(margin, canvas.height - margin);
        ctx.lineTo(margin, margin); // y-axis
        ctx.stroke();

        // axis labels
        ctx.fillText(
          "X (m)",
          canvas.width - margin - 20,
          canvas.height - margin + 30
        );
        ctx.fillText("Y (m)", margin - 30, margin - 10);
      }

      function animate(Vx, Vy, maxX, maxY) {
        let t = 0;
        const dt = 0.02; // time step in seconds

        function drawFrame() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Draw grid and axes
          drawAxes(maxX, maxY);

          // Draw trajectory
          ctx.strokeStyle = "blue";
          ctx.beginPath();
          for (let tt = 0; tt <= flightTime; tt += 0.1) {
            const x = Vx * tt;
            const y = Vy * tt - 0.5 * g * tt * tt;
            const cx = margin + x * scale;
            const cy = canvas.height - margin - y * scale;
            if (tt === 0) ctx.moveTo(cx, cy);
            else ctx.lineTo(cx, cy);
          }
          ctx.stroke();

          // Mark time points
          [1, 3, 5, 9].forEach((sec) => {
            const x = Vx * sec;
            const y = Vy * sec - 0.5 * g * sec * sec;
            const cx = margin + x * scale;
            const cy = canvas.height - margin - y * scale;
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText(`${sec}s`, cx + 8, cy);
          });

          // Draw ball at current time
          const x = Vx * t;
          const y = Vy * t - 0.5 * g * t * t;
          const cx = margin + x * scale;
          const cy = canvas.height - margin - y * scale;

          ctx.fillStyle = "green";
          ctx.beginPath();
          ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
          ctx.fill();

          if (t < flightTime) {
            t += dt;
            requestAnimationFrame(drawFrame);
          }
        }

        drawFrame();
      }
    </script>
  </body>
</html>
